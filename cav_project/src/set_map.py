def set_map(self, ID):
    if ID == "limo795":
       #coordinates of every critical point
      #coordinates of every critical point
       self.lane_width = 450
       self.pt_a = (3060, -1890)
       self.pt_b = (3061, 2671)
       self.pt_c = (1922, -1977)
       self.pt_d = (1826, -650)
       self.pt_e = (1980, 2507)
       self.pt_f = (706, 2662)
       self.pt_g = (183, 280.17)
       self.pt_h = (451, 640)
       self.pt_i = (1600, -1837)
       self.pt_j = (-2018.5, -1957)
       self.pt_j1 = (-2036, -216)
       self.pt_k = (-2027, 270.1)
       self.pt_l = (-2036, 634 )
       self.pt_m = (-2035, 2563)
       self.pt_n = (-2453, -1917)
       self.pt_o = (-2500, 276.1)
       self.pt_p = (-2573, 669)
       self.pt_q = (-2399, 2527)
       self.pt_r = (-4712, -1895)
       self.pt_s = (-4690, 277.6)
       self.pt_t = (-4631, 630)
       self.pt_u = (-4693, 2641)



       #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
       self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
       self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
       self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
       self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
       self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
       self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
       self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
       self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
       self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
       self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
       self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
       self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
       self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
       self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
       self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
       self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

       #the ranges near each corner that activates the circle path for the limo to follow
       self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
       self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
       self.act_range_d = (self.lane_width*1 , self.lane_width /2)
       self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
       self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
       self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
       self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
       self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
       self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
       self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

       self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
       self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
       self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
       self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
       self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
       self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
       self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
       self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


       #values of each line, each element is a tuple (kp, ki, kd)
       self.path_A_PID = (-0.00055, -0.000095, -0.001)
       self.path_B_PID = (0.00055, 0.00003, 0.0009)
       self.path_C_PID = (0.0008, 0.00008, 0.0012)
       self.path_D_PID = (-0.0008, -0.00007, -0.0008)
       self.path_D2_PID = (-0.0005, -0.00042, -0.001)
       self.path_E_PID =(-0.0004, -0.00033, -0.0016)
       self.path_F_PID = (-0.0004, -0.00033, -0.0016)
       self.path_G_PID = (-0.0008, -0.00007, -0.0008)
       self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
       self.path_H_PID = (0.00068, 0.00007, 0.0013)
       self.path_I_PID = (0.0008, 0.00008, 0.0008)
       self.path_J_PID = (-0.00035, -0.000075, -0.0012)
       self.path_K_PID = (-0.0008, -0.00004, -0.001)

       #PID values of each circle, each element is a tuple (kp, ki, kd)
       self.circle_a_PID = (-0.45, -0.00045, -0.037)
       self.circle_b_PID = (-0.45, -0.00045, -0.039)
       self.circle_c_PID = (-0.56, -0.00045, -0.037)
       self.circle_d_PID = (-0.0005, -0.00045, -0.03)
       self.circle_e_PID = (-0.003, -0.000045, -0.0017)
       self.circle_f_PID = (-0.50, -0.00045, -0.037)
       self.circle_g_PID = (-0.25, -0.000005, -0.07)
       self.circle_h_PID =(0.007, 0.0000012, 0.8)
       self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
       self.circle_j_PID = (-0.6, -0.000005, -0.037)
       self.circle_j1_PID = (-0.6, -0.000005, -0.037)
       self.circle_k_PID = (-0.25, -0.000005, -0.07)
       self.circle_l_PID =(-0.6, -0.00045, -0.037)
       self.circle_m_PID = (-0.6, -0.00045, -0.037)
       self.circle_n_PID =(-0.45, -0.00045, -0.037)
       self.circle_o_PID = (-0.45, -0.00045, -0.67)
       self.circle_p_PID =  (-0.25, -0.000005, -0.7)
       self.circle_q_PID = (-0.25, -0.000005, -0.7)
       self.circle_r_PID = (-0.6, -0.00045, -0.037)
       self.circle_s_PID = (-0.6, -0.00045, -0.037)
       self.circle_t_PID = (-0.6, -0.00045, -0.037)
       self.circle_u_PID = (-0.6, -0.00045, -0.37)


    if ID == "limo155":



       #coordinates of every critical poin
      #coordinates of every critical point
      #coordinates of every critical point
       self.lane_width = 450
       self.pt_a = (3060, -1890)
       self.pt_b = (3061, 2671)
       self.pt_c = (1922, -1977)
       self.pt_d = (1826, -650)
       self.pt_e = (1980, 2507)
       self.pt_f = (706, 2662)
       self.pt_g = (183, 280.17)
       self.pt_h = (451, 640)
       self.pt_i = (1600, -1837)
       self.pt_j = (-2018.5, -1957)
       self.pt_j1 = (-2036, -216)
       self.pt_k = (-2027, 270.1)
       self.pt_l = (-2036, 634 )
       self.pt_m = (-2035, 2563)
       self.pt_n = (-2453, -1917)
       self.pt_o = (-2500, 276.1)
       self.pt_p = (-2573, 669)
       self.pt_q = (-2399, 2527)
       self.pt_r = (-4712, -1895)
       self.pt_s = (-4690, 277.6)
       self.pt_t = (-4631, 630)
       self.pt_u = (-4693, 2641)



       #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
       self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
       self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
       self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
       self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
       self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
       self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
       self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
       self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
       self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
       self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
       self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
       self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
       self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
       self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
       self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
       self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

       #the ranges near each corner that activates the circle path for the limo to follow
       self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
       self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
       self.act_range_d = (self.lane_width*1 , self.lane_width /2)
       self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
       self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
       self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
       self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
       self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
       self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
       self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

       self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
       self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
       self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
       self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
       self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
       self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
       self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
       self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


       #values of each line, each element is a tuple (kp, ki, kd)
       self.path_A_PID = (-0.00055, -0.000095, -0.001)
       self.path_B_PID = (0.00055, 0.00003, 0.0009)
       self.path_C_PID = (0.0008, 0.00008, 0.0012)
       self.path_D_PID = (-0.0008, -0.00007, -0.0008)
       self.path_D2_PID = (-0.0005, -0.00042, -0.001)
       self.path_E_PID =(-0.0004, -0.00033, -0.0016)
       self.path_F_PID = (-0.0004, -0.00033, -0.0016)
       self.path_G_PID = (-0.0008, -0.00007, -0.0008)
       self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
       self.path_H_PID = (0.00068, 0.00007, 0.0013)
       self.path_I_PID = (0.0008, 0.00008, 0.0008)
       self.path_J_PID = (-0.00035, -0.000075, -0.0012)
       self.path_K_PID = (-0.0008, -0.00004, -0.001)

       #PID values of each circle, each element is a tuple (kp, ki, kd)
       self.circle_a_PID = (-0.45, -0.00045, -0.037)
       self.circle_b_PID = (-0.45, -0.00045, -0.039)
       self.circle_c_PID = (-0.56, -0.00045, -0.037)
       self.circle_d_PID = (-0.0005, -0.00045, -0.03)
       self.circle_e_PID = (-0.003, -0.000045, -0.0017)
       self.circle_f_PID = (-0.50, -0.00045, -0.037)
       self.circle_g_PID = (-0.25, -0.000005, -0.07)
       self.circle_h_PID =(0.007, 0.0000012, 0.8)
       self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
       self.circle_j_PID = (-0.6, -0.000005, -0.037)
       self.circle_j1_PID = (-0.6, -0.000005, -0.037)
       self.circle_k_PID = (-0.25, -0.000005, -0.07)
       self.circle_l_PID =(-0.6, -0.00045, -0.037)
       self.circle_m_PID = (-0.6, -0.00045, -0.037)
       self.circle_n_PID =(-0.45, -0.00045, -0.037)
       self.circle_o_PID = (-0.45, -0.00045, -0.67)
       self.circle_p_PID =  (-0.25, -0.000005, -0.7)
       self.circle_q_PID = (-0.25, -0.000005, -0.7)
       self.circle_r_PID = (-0.6, -0.00045, -0.037)
       self.circle_s_PID = (-0.6, -0.00045, -0.037)
       self.circle_t_PID = (-0.6, -0.00045, -0.037)
       self.circle_u_PID = (-0.6, -0.00045, -0.37)





    if ID == "limo789":
       #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (3060, -1900)
        self.pt_b = (3061, 2671)
        self.pt_c = (1953, -1977)
        self.pt_d = (1877, -624)
        self.pt_e = (1980, 2507)
        self.pt_f = (522, 2507)
        self.pt_g = (183, 280.17)
        self.pt_h = (451, 640)
        self.pt_i = (1600, -1837)
        self.pt_j = (-2018.5, -1957)
        self.pt_k = (-2027, 270.1)
        self.pt_l = (-2036, 634 )
        self.pt_m = (-1937.2, 2660.1)
        self.pt_n = (-2399, -1815.8)
        self.pt_o = (-2500, 276.1)
        self.pt_p = (-2573, 669)
        self.pt_q = (-2399, 2527)
        self.pt_r = (-4712, -1923)
        self.pt_s = (-4690, 277.6)
        self.pt_t = (-4631, 630)
        self.pt_u = (-4693, 2641)



        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
        self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_n = (self.pt_n[0] - self.lane_width, self.pt_n[1] + self.lane_width, self.lane_width)
        self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
        self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width)
        self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_b = (self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
        self.act_range_d = (self.lane_width , self.lane_width /2)
        self.act_range_e = (self.lane_width * 1.1, self.lane_width/1.7 )
        self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.1)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width /1.85, self.lane_width * 1.69)
        self.act_range_i = (self.lane_width /1.35, self.lane_width * 0.7)
        self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
        self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
        self.act_range_m = (self.lane_width * 1.1, self.lane_width/1.7 )
        self.act_range_n = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.5)
        self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_t = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_u = (self.lane_width * 1.1, self.lane_width/1.7 )


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (-0.00055, -0.000095, -0.001)
        self.path_B_PID = (0.00068, 0.00007, 0.0013)
        self.path_C_PID = (0.0008, 0.00008, 0.0008)
        self.path_D_PID = (-0.0005, -0.00042, -0.001)
        self.path_D2_PID = (-0.0005, -0.00042, -0.001)
        self.path_E_PID =(-0.0004, -0.00053, -0.001)
        self.path_F_PID = (-0.0004, -0.00033, -0.0016)
        self.path_G_PID = (-0.0008, -0.00007, -0.0008)
        self.path_H_PID = (0.00068, 0.00007, 0.0013)
        self.path_I_PID = (0.0008, 0.00008, 0.0008)
        self.path_J_PID = (-0.00035, -0.000075, -0.0012)
        self.path_K_PID = (-0.0008, -0.00004, -0.001)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.6, -0.00045, -0.37)
        self.circle_b_PID = (-0.6, -0.00045, -0.37)
        self.circle_c_PID = (-0.6, -0.00045, -0.37)
        self.circle_d_PID = (-0.0005, -0.00045, -0.03)
        self.circle_e_PID = (-0.6, -0.00045, -0.37)
        self.circle_f_PID = (-0.50, -0.00045, -0.037)
        self.circle_g_PID = (-0.25, -0.000005, -0.7)
        self.circle_h_PID =(0.007, 0.0000012, 0.8)
        self.circle_i_PID = (-0.5, -0.00045, -0.6)
        self.circle_j_PID = (-0.6, -0.000005, -0.37)
        self.circle_k_PID = (-0.25, -0.000005, -0.7)
        self.circle_l_PID =(-0.6, -0.00045, -0.37)
        self.circle_m_PID = (-0.6, -0.00045, -0.37)
        self.circle_n_PID =(-0.6, -0.00075, -0.37)
        self.circle_o_PID = (-0.45, -0.00045, -0.67)
        self.circle_p_PID =  (-0.25, -0.000005, -0.7)
        self.circle_q_PID = (-0.25, -0.000005, -0.7)
        self.circle_r_PID = (-0.6, -0.00045, -0.37)
        self.circle_s_PID = (-0.6, -0.00045, -0.37)
        self.circle_t_PID = (-0.25, -0.000005, -0.7)
        self.circle_u_PID = (-0.6, -0.00045, -0.37)

    if ID == "limo780":
       #coordinates of every critical point



       #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (3060, -1890)
        self.pt_b = (3061, 2671)
        self.pt_c = (1922, -1977)
        self.pt_d = (1902, -671)
        self.pt_e = (1980, 2507)
        self.pt_f = (683, 2536)
        self.pt_g = (183, 280.17)
        self.pt_h = (451, 640)
        self.pt_i = (1600, -1837)
        self.pt_j = (-2018.5, -1957)
        self.pt_j1 = (-2036, -216)
        self.pt_k = (-2027, 270.1)
        self.pt_l = (-2036, 634 )
        self.pt_m = (-2035, 2563)
        self.pt_n = (-2453, -1917)
        self.pt_o = (-2500, 276.1)
        self.pt_p = (-2573, 669)
        self.pt_q = (-2399, 2527)
        self.pt_r = (-4712, -1895)
        self.pt_s = (-4690, 277.6)
        self.pt_t = (-4631, 630)
        self.pt_u = (-4693, 2641)



        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
        self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
        self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
        self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
        self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
        self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
        self.act_range_d = (self.lane_width*1 , self.lane_width /2)
        self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
        self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
        self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
        self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
        self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

        self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
        self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
        self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
        self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
        self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (-0.00055, -0.000095, -0.001)
        self.path_B_PID = (0.00055, 0.00003, 0.0009)
        self.path_C_PID = (0.0008, 0.00008, 0.0012)
        self.path_D_PID = (-0.0008, -0.00007, -0.0008)
        self.path_D2_PID = (-0.0005, -0.00042, -0.001)
        self.path_E_PID =(-0.0004, -0.00053, -0.001)
        self.path_F_PID = (-0.0004, -0.00033, -0.0016)
        self.path_G_PID = (-0.0008, -0.00007, -0.0008)
        self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
        self.path_H_PID = (0.00068, 0.00007, 0.0013)
        self.path_I_PID = (0.0008, 0.00008, 0.0008)
        self.path_J_PID = (-0.00035, -0.000075, -0.0012)
        self.path_K_PID = (-0.0008, -0.00004, -0.001)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.45, -0.00045, -0.037)
        self.circle_b_PID = (-0.45, -0.00045, -0.039)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.03)
        self.circle_e_PID = (-0.003, -0.000045, -0.0017)
        self.circle_f_PID = (-0.50, -0.00045, -0.037)
        self.circle_g_PID = (-0.25, -0.000005, -0.07)
        self.circle_h_PID =(0.007, 0.0000012, 0.8)
        self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
        self.circle_j_PID = (-0.6, -0.000005, -0.037)
        self.circle_j1_PID = (-0.6, -0.000005, -0.037)
        self.circle_k_PID = (-0.25, -0.000005, -0.07)
        self.circle_l_PID =(-0.6, -0.00045, -0.037)
        self.circle_m_PID = (-0.6, -0.00045, -0.037)
        self.circle_n_PID =(-0.45, -0.00045, -0.037)
        self.circle_o_PID = (-0.45, -0.00045, -0.67)
        self.circle_p_PID =  (-0.25, -0.000005, -0.7)
        self.circle_q_PID = (-0.25, -0.000005, -0.7)
        self.circle_r_PID = (-0.6, -0.00045, -0.037)
        self.circle_s_PID = (-0.6, -0.00045, -0.037)
        self.circle_t_PID = (-0.6, -0.00045, -0.037)
        self.circle_u_PID = (-0.6, -0.00045, -0.37)

    if ID == "limo799":



       #coordinates of every critical point
       #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (3060, -1890)
        self.pt_b = (3061, 2671)
        self.pt_c = (1922, -1977)
        self.pt_d = (1902, -671)
        self.pt_e = (1980, 2507)
        self.pt_f = (683, 2536)
        self.pt_g = (183, 280.17)
        self.pt_h = (451, 640)
        self.pt_i = (1600, -1837)
        self.pt_j = (-2018.5, -1957)
        self.pt_j1 = (-2036, -216)
        self.pt_k = (-2027, 270.1)
        self.pt_l = (-2036, 634 )
        self.pt_m = (-2035, 2563)
        self.pt_n = (-2453, -1917)
        self.pt_o = (-2500, 276.1)
        self.pt_p = (-2573, 669)
        self.pt_q = (-2399, 2527)
        self.pt_r = (-4712, -1895)
        self.pt_s = (-4690, 277.6)
        self.pt_t = (-4631, 630)
        self.pt_u = (-4693, 2641)



        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
        self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
        self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
        self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
        self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
        self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
        self.act_range_d = (self.lane_width*1 , self.lane_width /2)
        self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
        self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
        self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
        self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
        self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

        self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
        self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
        self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
        self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
        self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (-0.00055, -0.000095, -0.001)
        self.path_B_PID = (0.00055, 0.00003, 0.0009)
        self.path_C_PID = (0.0008, 0.00008, 0.0012)
        self.path_D_PID = (-0.0008, -0.00007, -0.0008)
        self.path_D2_PID = (-0.0005, -0.00042, -0.001)
        self.path_E_PID =(-0.0004, -0.00053, -0.001)
        self.path_F_PID = (-0.0004, -0.00033, -0.0016)
        self.path_G_PID = (-0.0008, -0.00007, -0.0008)
        self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
        self.path_H_PID = (0.00068, 0.00007, 0.0013)
        self.path_I_PID = (0.0008, 0.00008, 0.0008)
        self.path_J_PID = (-0.00035, -0.000075, -0.0012)
        self.path_K_PID = (-0.0008, -0.00004, -0.001)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.45, -0.00045, -0.037)
        self.circle_b_PID = (-0.45, -0.00045, -0.039)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.03)
        self.circle_e_PID = (-0.003, -0.000045, -0.0017)
        self.circle_f_PID = (-0.50, -0.00045, -0.037)
        self.circle_g_PID = (-0.25, -0.000005, -0.07)
        self.circle_h_PID =(0.007, 0.0000012, 0.8)
        self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
        self.circle_j_PID = (-0.6, -0.000005, -0.037)
        self.circle_j1_PID = (-0.6, -0.000005, -0.037)
        self.circle_k_PID = (-0.25, -0.000005, -0.07)
        self.circle_l_PID =(-0.6, -0.00045, -0.037)
        self.circle_m_PID = (-0.6, -0.00045, -0.037)
        self.circle_n_PID =(-0.45, -0.00045, -0.037)
        self.circle_o_PID = (-0.45, -0.00045, -0.67)
        self.circle_p_PID =  (-0.25, -0.000005, -0.7)
        self.circle_q_PID = (-0.25, -0.000005, -0.7)
        self.circle_r_PID = (-0.6, -0.00045, -0.037)
        self.circle_s_PID = (-0.6, -0.00045, -0.037)
        self.circle_t_PID = (-0.6, -0.00045, -0.037)
        self.circle_u_PID = (-0.6, -0.00045, -0.37)

    if ID == "limo789":
       #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (3060, -1900)
        self.pt_b = (3061, 2671)
        self.pt_c = (1953, -1977)
        self.pt_d = (1877, -624)
        self.pt_e = (1980, 2507)
        self.pt_f = (522, 2507)
        self.pt_g = (183, 280.17)
        self.pt_h = (451, 640)
        self.pt_i = (1600, -1837)
        self.pt_j = (-2018.5, -1957)
        self.pt_k = (-2027, 270.1)
        self.pt_l = (-2036, 634 )
        self.pt_m = (-1937.2, 2660.1)
        self.pt_n = (-2399, -1815.8)
        self.pt_o = (-2500, 276.1)
        self.pt_p = (-2573, 669)
        self.pt_q = (-2399, 2527)
        self.pt_r = (-4712, -1923)
        self.pt_s = (-4690, 277.6)
        self.pt_t = (-4631, 630)
        self.pt_u = (-4693, 2641)



        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
        self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_n = (self.pt_n[0] - self.lane_width, self.pt_n[1] + self.lane_width, self.lane_width)
        self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
        self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width)
        self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_b = (self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
        self.act_range_d = (self.lane_width , self.lane_width /2)
        self.act_range_e = (self.lane_width * 1.1, self.lane_width/1.7 )
        self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.1)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
        self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
        self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
        self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
        self.act_range_m = (self.lane_width * 1.1, self.lane_width/1.7 )
        self.act_range_n = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.5)
        self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_t = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_u = (self.lane_width *1.3, self.lane_width/1.7 )


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (-0.00055, -0.000095, -0.001)
        self.path_B_PID = (0.00068, 0.00007, 0.0013)
        self.path_C_PID = (0.0008, 0.00008, 0.0008)
        self.path_D_PID = (-0.0005, -0.00042, -0.001)
        self.path_D2_PID = (-0.0005, -0.00042, -0.001)
        self.path_E_PID =(-0.0004, -0.00053, -0.001)
        self.path_F_PID = (-0.0004, -0.00033, -0.0016)
        self.path_G_PID = (-0.0008, -0.00007, -0.0008)
        self.path_H_PID = (0.00068, 0.00007, 0.0013)
        self.path_I_PID = (0.0008, 0.00008, 0.0008)
        self.path_J_PID = (-0.00035, -0.000075, -0.0012)
        self.path_K_PID = (-0.0008, -0.00004, -0.001)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.6, -0.00045, -0.37)
        self.circle_b_PID = (-0.6, -0.00045, -0.37)
        self.circle_c_PID = (-0.6, -0.00045, -0.37)
        self.circle_d_PID = (-0.0005, -0.00045, -0.03)
        self.circle_e_PID = (-0.6, -0.00045, -0.37)
        self.circle_f_PID = (-0.50, -0.00045, -0.037)
        self.circle_g_PID = (-0.25, -0.000005, -0.7)
        self.circle_h_PID =(0.007, 0.0000012, 0.8)
        self.circle_i_PID = (-0.5, -0.00045, -0.6)
        self.circle_j_PID = (-0.6, -0.000005, -0.37)
        self.circle_k_PID = (-0.25, -0.000005, -0.7)
        self.circle_l_PID =(-0.6, -0.00045, -0.37)
        self.circle_m_PID = (-0.6, -0.00045, -0.37)
        self.circle_n_PID =(-0.6, -0.00075, -0.37)
        self.circle_o_PID = (-0.45, -0.00045, -0.67)
        self.circle_p_PID =  (-0.25, -0.000005, -0.7)
        self.circle_q_PID = (-0.25, -0.000005, -0.7)
        self.circle_r_PID = (-0.6, -0.00045, -0.37)
        self.circle_s_PID = (-0.6, -0.00045, -0.37)
        self.circle_t_PID = (-0.25, -0.000005, -0.7)
        self.circle_u_PID = (-0.6, -0.00045, -0.37)

    if ID == "limo770":
       #coordinates of every critical point
       #coordinates of every critical point
       self.lane_width = 450
       self.pt_a = (3060, -1890)
       self.pt_b = (3061, 2671)
       self.pt_c = (1922, -1977)
       self.pt_d = (1826, -650)
       self.pt_e = (1980, 2507)
       self.pt_f = (706, 2662)
       self.pt_g = (183, 280.17)
       self.pt_h = (451, 640)
       self.pt_i = (1600, -1837)
       self.pt_j = (-2018.5, -1957)
       self.pt_j1 = (-2036, -216)
       self.pt_k = (-2027, 270.1)
       self.pt_l = (-2036, 634 )
       self.pt_m = (-2035, 2563)
       self.pt_n = (-2453, -1917)
       self.pt_o = (-2500, 276.1)
       self.pt_p = (-2573, 669)
       self.pt_q = (-2399, 2527)
       self.pt_r = (-4712, -1895)
       self.pt_s = (-4690, 277.6)
       self.pt_t = (-4631, 630)
       self.pt_u = (-4693, 2641)



       #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
       self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
       self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
       self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
       self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
       self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
       self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
       self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
       self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
       self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
       self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
       self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
       self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
       self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
       self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
       self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
       self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

       #the ranges near each corner that activates the circle path for the limo to follow
       self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
       self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
       self.act_range_d = (self.lane_width*1 , self.lane_width /2)
       self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
       self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
       self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
       self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
       self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
       self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
       self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

       self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
       self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
       self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
       self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
       self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
       self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
       self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
       self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


       #values of each line, each element is a tuple (kp, ki, kd)
       self.path_A_PID = (-0.00055, -0.000095, -0.001)
       self.path_B_PID = (0.00055, 0.00003, 0.0009)
       self.path_C_PID = (0.0008, 0.00008, 0.0012)
       self.path_D_PID = (-0.0008, -0.00007, -0.0008)
       self.path_D2_PID = (-0.0005, -0.00042, -0.001)
       self.path_E_PID =(-0.0004, -0.00033, -0.0016)
       self.path_F_PID = (-0.0004, -0.00033, -0.0016)
       self.path_G_PID = (-0.0008, -0.00007, -0.0008)
       self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
       self.path_H_PID = (0.00068, 0.00007, 0.0013)
       self.path_I_PID = (0.0008, 0.00008, 0.0008)
       self.path_J_PID = (-0.00035, -0.000075, -0.0012)
       self.path_K_PID = (-0.0008, -0.00004, -0.001)

       #PID values of each circle, each element is a tuple (kp, ki, kd)
       self.circle_a_PID = (-0.45, -0.00045, -0.037)
       self.circle_b_PID = (-0.45, -0.00045, -0.039)
       self.circle_c_PID = (-0.56, -0.00045, -0.037)
       self.circle_d_PID = (-0.0005, -0.00045, -0.03)
       self.circle_e_PID = (-0.003, -0.000045, -0.0017)
       self.circle_f_PID = (-0.50, -0.00045, -0.037)
       self.circle_g_PID = (-0.25, -0.000005, -0.07)
       self.circle_h_PID =(0.007, 0.0000012, 0.8)
       self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
       self.circle_j_PID = (-0.6, -0.000005, -0.037)
       self.circle_j1_PID = (-0.6, -0.000005, -0.037)
       self.circle_k_PID = (-0.25, -0.000005, -0.07)
       self.circle_l_PID =(-0.6, -0.00045, -0.037)
       self.circle_m_PID = (-0.6, -0.00045, -0.037)
       self.circle_n_PID =(-0.45, -0.00045, -0.037)
       self.circle_o_PID = (-0.45, -0.00045, -0.67)
       self.circle_p_PID =  (-0.25, -0.000005, -0.7)
       self.circle_q_PID = (-0.25, -0.000005, -0.7)
       self.circle_r_PID = (-0.6, -0.00045, -0.037)
       self.circle_s_PID = (-0.6, -0.00045, -0.037)
       self.circle_t_PID = (-0.6, -0.00045, -0.037)
       self.circle_u_PID = (-0.6, -0.00045, -0.37)




    if ID == "limo813":



       #coordinates of every critical point
       #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (3060, -1890)
        self.pt_b = (3061, 2671)
        self.pt_c = (1922, -1977)
        self.pt_d = (1826, -650)
        self.pt_e = (1980, 2507)
        self.pt_f = (706, 2662)
        self.pt_g = (183, 280.17)
        self.pt_h = (451, 640)
        self.pt_i = (1600, -1837)
        self.pt_j = (-2018.5, -1957)
        self.pt_j1 = (-2036, -216)
        self.pt_k = (-2027, 270.1)
        self.pt_l = (-2036, 634 )
        self.pt_m = (-2035, 2563)
        self.pt_n = (-2453, -1917)
        self.pt_o = (-2500, 276.1)
        self.pt_p = (-2573, 669)
        self.pt_q = (-2399, 2527)
        self.pt_r = (-4712, -1895)
        self.pt_s = (-4690, 277.6)
        self.pt_t = (-4631, 630)
        self.pt_u = (-4693, 2641)



        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
        self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
        self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
        self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
        self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
        self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
        self.act_range_d = (self.lane_width*1 , self.lane_width /2)
        self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
        self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
        self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
        self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
        self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

        self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
        self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
        self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
        self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
        self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (-0.00055, -0.000095, -0.001)
        self.path_B_PID = (0.00055, 0.00003, 0.0009)
        self.path_C_PID = (0.0008, 0.00008, 0.0012)
        self.path_D_PID = (-0.0008, -0.00007, -0.0008)
        self.path_D2_PID = (-0.0005, -0.00042, -0.001)
        self.path_E_PID =(-0.0004, -0.00033, -0.0016)
        self.path_F_PID = (-0.0004, -0.00033, -0.0016)
        self.path_G_PID = (-0.0008, -0.00007, -0.0008)
        self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
        self.path_H_PID = (0.00068, 0.00007, 0.0013)
        self.path_I_PID = (0.0008, 0.00008, 0.0008)
        self.path_J_PID = (-0.00035, -0.000075, -0.0012)
        self.path_K_PID = (-0.0008, -0.00004, -0.001)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.45, -0.00045, -0.037)
        self.circle_b_PID = (-0.45, -0.00045, -0.039)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.03)
        self.circle_e_PID = (-0.003, -0.000045, -0.0017)
        self.circle_f_PID = (-0.50, -0.00045, -0.037)
        self.circle_g_PID = (-0.25, -0.000005, -0.07)
        self.circle_h_PID =(0.007, 0.0000012, 0.8)
        self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
        self.circle_j_PID = (-0.6, -0.000005, -0.037)
        self.circle_j1_PID = (-0.6, -0.000005, -0.037)
        self.circle_k_PID = (-0.25, -0.000005, -0.07)
        self.circle_l_PID =(-0.6, -0.00045, -0.037)
        self.circle_m_PID = (-0.6, -0.00045, -0.037)
        self.circle_n_PID =(-0.45, -0.00045, -0.037)
        self.circle_o_PID = (-0.45, -0.00045, -0.67)
        self.circle_p_PID =  (-0.25, -0.000005, -0.7)
        self.circle_q_PID = (-0.25, -0.000005, -0.7)
        self.circle_r_PID = (-0.6, -0.00045, -0.037)
        self.circle_s_PID = (-0.6, -0.00045, -0.037)
        self.circle_t_PID = (-0.6, -0.00045, -0.037)
        self.circle_u_PID = (-0.6, -0.00045, -0.37)






    if ID == "limo777":



       #coordinates of every critical point
       self.lane_width = 450
       self.pt_a = (3060, -1890)
       self.pt_b = (3061, 2671)
       self.pt_c = (1922, -1977)
       self.pt_d = (1826, -650)
       self.pt_e = (1980, 2507)
       self.pt_f = (706, 2662)
       self.pt_g = (183, 280.17)
       self.pt_h = (451, 640)
       self.pt_i = (1600, -1837)
       self.pt_j = (-2018.5, -1957)
       self.pt_j1 = (-2036, -216)
       self.pt_k = (-2027, 270.1)
       self.pt_l = (-2036, 634 )
       self.pt_m = (-2035, 2563)
       self.pt_n = (-2453, -1917)
       self.pt_o = (-2500, 276.1)
       self.pt_p = (-2573, 669)
       self.pt_q = (-2399, 2527)
       self.pt_r = (-4712, -1895)
       self.pt_s = (-4690, 277.6)
       self.pt_t = (-4631, 630)
       self.pt_u = (-4693, 2641)



       #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
       self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
       self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
       self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
       self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
       self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
       self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
       self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
       self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
       self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
       self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
       self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
       self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
       self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
       self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
       self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
       self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

       #the ranges near each corner that activates the circle path for the limo to follow
       self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
       self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
       self.act_range_d = (self.lane_width*1 , self.lane_width /2)
       self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
       self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
       self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
       self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
       self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
       self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
       self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

       self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
       self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
       self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
       self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
       self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
       self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
       self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
       self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


       #values of each line, each element is a tuple (kp, ki, kd)
       self.path_A_PID = (-0.00055, -0.000095, -0.001)
       self.path_B_PID = (0.00055, 0.00003, 0.0009)
       self.path_C_PID = (0.0008, 0.00008, 0.0012)
       self.path_D_PID = (-0.0008, -0.00007, -0.0008)
       self.path_D2_PID = (-0.0005, -0.00042, -0.001)
       self.path_E_PID =(-0.0004, -0.00033, -0.0016)
       self.path_F_PID = (-0.0004, -0.00033, -0.0016)
       self.path_G_PID = (-0.0008, -0.00007, -0.0008)
       self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
       self.path_H_PID = (0.00068, 0.00007, 0.0013)
       self.path_I_PID = (0.0008, 0.00008, 0.0008)
       self.path_J_PID = (-0.00035, -0.000075, -0.0012)
       self.path_K_PID = (-0.0008, -0.00004, -0.001)

       #PID values of each circle, each element is a tuple (kp, ki, kd)
       self.circle_a_PID = (-0.45, -0.00045, -0.037)
       self.circle_b_PID = (-0.45, -0.00045, -0.039)
       self.circle_c_PID = (-0.56, -0.00045, -0.037)
       self.circle_d_PID = (-0.0005, -0.00045, -0.03)
       self.circle_e_PID = (-0.003, -0.000045, -0.0017)
       self.circle_f_PID = (-0.50, -0.00045, -0.037)
       self.circle_g_PID = (-0.25, -0.000005, -0.07)
       self.circle_h_PID =(0.007, 0.0000012, 0.8)
       self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
       self.circle_j_PID = (-0.6, -0.000005, -0.037)
       self.circle_j1_PID = (-0.6, -0.000005, -0.037)
       self.circle_k_PID = (-0.25, -0.000005, -0.07)
       self.circle_l_PID =(-0.6, -0.00045, -0.037)
       self.circle_m_PID = (-0.6, -0.00045, -0.037)
       self.circle_n_PID =(-0.45, -0.00045, -0.037)
       self.circle_o_PID = (-0.45, -0.00045, -0.67)
       self.circle_p_PID =  (-0.25, -0.000005, -0.7)
       self.circle_q_PID = (-0.25, -0.000005, -0.7)
       self.circle_r_PID = (-0.6, -0.00045, -0.037)
       self.circle_s_PID = (-0.6, -0.00045, -0.037)
       self.circle_t_PID = (-0.6, -0.00045, -0.037)
       self.circle_u_PID = (-0.6, -0.00045, -0.37)

    if ID == "limo793":

       #coordinates of every critical point
       #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (3060, -1890)
        self.pt_b = (3061, 2671)
        self.pt_c = (1922, -1977)
        self.pt_d = (1902, -671)
        self.pt_e = (1980, 2507)
        self.pt_f = (683, 2536)
        self.pt_g = (183, 280.17)
        self.pt_h = (451, 640)
        self.pt_i = (1600, -1837)
        self.pt_j = (-2018.5, -1957)
        self.pt_j1 = (-2036, -216)
        self.pt_k = (-2027, 270.1)
        self.pt_l = (-2036, 634 )
        self.pt_m = (-2035, 2563)
        self.pt_n = (-2453, -1917)
        self.pt_o = (-2500, 276.1)
        self.pt_p = (-2573, 669)
        self.pt_q = (-2399, 2527)
        self.pt_r = (-4712, -1895)
        self.pt_s = (-4690, 277.6)
        self.pt_t = (-4631, 630)
        self.pt_u = (-4693, 2641)



        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
        self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
        self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
        self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
        self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
        self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
        self.act_range_d = (self.lane_width*1 , self.lane_width /2)
        self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
        self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
        self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
        self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
        self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

        self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
        self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
        self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
        self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
        self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (-0.00055, -0.000095, -0.001)
        self.path_B_PID = (0.00055, 0.00003, 0.0009)
        self.path_C_PID = (0.0008, 0.00008, 0.0012)
        self.path_D_PID = (-0.0008, -0.00007, -0.0008)
        self.path_D2_PID = (-0.0005, -0.00042, -0.001)
        self.path_E_PID =(-0.0004, -0.00053, -0.001)
        self.path_F_PID = (-0.0004, -0.00033, -0.0016)
        self.path_G_PID = (-0.0008, -0.00007, -0.0008)
        self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
        self.path_H_PID = (0.00068, 0.00007, 0.0013)
        self.path_I_PID = (0.0008, 0.00008, 0.0008)
        self.path_J_PID = (-0.00035, -0.000075, -0.0012)
        self.path_K_PID = (-0.0008, -0.00004, -0.001)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.45, -0.00045, -0.037)
        self.circle_b_PID = (-0.45, -0.00045, -0.039)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.03)
        self.circle_e_PID = (-0.003, -0.000045, -0.0017)
        self.circle_f_PID = (-0.50, -0.00045, -0.037)
        self.circle_g_PID = (-0.25, -0.000005, -0.07)
        self.circle_h_PID =(0.007, 0.0000012, 0.8)
        self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
        self.circle_j_PID = (-0.6, -0.000005, -0.037)
        self.circle_j1_PID = (-0.6, -0.000005, -0.037)
        self.circle_k_PID = (-0.25, -0.000005, -0.07)
        self.circle_l_PID =(-0.6, -0.00045, -0.037)
        self.circle_m_PID = (-0.6, -0.00045, -0.037)
        self.circle_n_PID =(-0.45, -0.00045, -0.037)
        self.circle_o_PID = (-0.45, -0.00045, -0.67)
        self.circle_p_PID =  (-0.25, -0.000005, -0.7)
        self.circle_q_PID = (-0.25, -0.000005, -0.7)
        self.circle_r_PID = (-0.6, -0.00045, -0.037)
        self.circle_s_PID = (-0.6, -0.00045, -0.037)
        self.circle_t_PID = (-0.6, -0.00045, -0.037)
        self.circle_u_PID = (-0.6, -0.00045, -0.37)







    if ID == "limo808":

       #coordinates of every critical point
       self.lane_width = 450
       self.pt_a = (3060, -1890)
       self.pt_b = (3061, 2671)
       self.pt_c = (1922, -1977)
       self.pt_d = (1826, -650)
       self.pt_e = (1980, 2507)
       self.pt_f = (706, 2662)
       self.pt_g = (183, 280.17)
       self.pt_h = (451, 640)
       self.pt_i = (1600, -1837)
       self.pt_j = (-2018.5, -1957)
       self.pt_j1 = (-2036, -216)
       self.pt_k = (-2027, 270.1)
       self.pt_l = (-2036, 634 )
       self.pt_m = (-2035, 2563)
       self.pt_n = (-2453, -1917)
       self.pt_o = (-2500, 276.1)
       self.pt_p = (-2573, 669)
       self.pt_q = (-2399, 2527)
       self.pt_r = (-4712, -1895)
       self.pt_s = (-4690, 277.6)
       self.pt_t = (-4631, 630)
       self.pt_u = (-4693, 2641)



       #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
       self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
       self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
       self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
       self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
       self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
       self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
       self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
       self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
       self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
       self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
       self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
       self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
       self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
       self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
       self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
       self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
       self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
       self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

       #the ranges near each corner that activates the circle path for the limo to follow
       self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
       self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
       self.act_range_d = (self.lane_width*1 , self.lane_width /2)
       self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
       self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
       self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
       self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
       self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
       self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
       self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

       self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
       self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
       self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
       self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
       self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
       self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
       self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
       self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
       self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
       self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


       #values of each line, each element is a tuple (kp, ki, kd)
       self.path_A_PID = (-0.00055, -0.000095, -0.001)
       self.path_B_PID = (0.00055, 0.00003, 0.0009)
       self.path_C_PID = (0.0008, 0.00008, 0.0012)
       self.path_D_PID = (-0.0008, -0.00007, -0.0008)
       self.path_D2_PID = (-0.0005, -0.00042, -0.001)
       self.path_E_PID =(-0.0004, -0.00033, -0.0016)
       self.path_F_PID = (-0.0004, -0.00033, -0.0016)
       self.path_G_PID = (-0.0008, -0.00007, -0.0008)
       self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
       self.path_H_PID = (0.00068, 0.00007, 0.0013)
       self.path_I_PID = (0.0008, 0.00008, 0.0008)
       self.path_J_PID = (-0.00035, -0.000075, -0.0012)
       self.path_K_PID = (-0.0008, -0.00004, -0.001)

       #PID values of each circle, each element is a tuple (kp, ki, kd)
       self.circle_a_PID = (-0.45, -0.00045, -0.037)
       self.circle_b_PID = (-0.45, -0.00045, -0.039)
       self.circle_c_PID = (-0.56, -0.00045, -0.037)
       self.circle_d_PID = (-0.0005, -0.00045, -0.03)
       self.circle_e_PID = (-0.003, -0.000045, -0.0017)
       self.circle_f_PID = (-0.50, -0.00045, -0.037)
       self.circle_g_PID = (-0.25, -0.000005, -0.07)
       self.circle_h_PID =(0.007, 0.0000012, 0.8)
       self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
       self.circle_j_PID = (-0.6, -0.000005, -0.037)
       self.circle_j1_PID = (-0.6, -0.000005, -0.037)
       self.circle_k_PID = (-0.25, -0.000005, -0.07)
       self.circle_l_PID =(-0.6, -0.00045, -0.037)
       self.circle_m_PID = (-0.6, -0.00045, -0.037)
       self.circle_n_PID =(-0.45, -0.00045, -0.037)
       self.circle_o_PID = (-0.45, -0.00045, -0.67)
       self.circle_p_PID =  (-0.25, -0.000005, -0.7)
       self.circle_q_PID = (-0.25, -0.000005, -0.7)
       self.circle_r_PID = (-0.6, -0.00045, -0.037)
       self.circle_s_PID = (-0.6, -0.00045, -0.037)
       self.circle_t_PID = (-0.6, -0.00045, -0.037)
       self.circle_u_PID = (-0.6, -0.00045, -0.37)



    if ID == "limo787":



       #coordinates of every critical point
       #coordinates of every critical point
        self.lane_width = 450
        self.pt_a = (3060, -1890)
        self.pt_b = (3061, 2671)
        self.pt_c = (1922, -1977)
        self.pt_d = (1902, -671)
        self.pt_e = (1980, 2507)
        self.pt_f = (683, 2536)
        self.pt_g = (183, 280.17)
        self.pt_h = (451, 640)
        self.pt_i = (1600, -1837)
        self.pt_j = (-2018.5, -1957)
        self.pt_j1 = (-2036, -216)
        self.pt_k = (-2027, 270.1)
        self.pt_l = (-2036, 634 )
        self.pt_m = (-2035, 2563)
        self.pt_n = (-2453, -1917)
        self.pt_o = (-2500, 276.1)
        self.pt_p = (-2573, 669)
        self.pt_q = (-2399, 2527)
        self.pt_r = (-4712, -1895)
        self.pt_s = (-4690, 277.6)
        self.pt_t = (-4631, 630)
        self.pt_u = (-4693, 2641)



        #data points that characterize each circle for the corners - center x, center y, radius. Each variable is a tuple (A, B, C)
        self.circle_a = (self.pt_a[0]- self.lane_width*1.2, self.pt_a[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_b = (self.pt_b[0] - self.lane_width, self.pt_b[1] - self.lane_width, self.lane_width/1.8)
        self.circle_c = (self.pt_c[0] + self.lane_width, self.pt_c[1] + self.lane_width, self.lane_width/2)
        self.circle_d = (self.pt_d[0] + self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width) #in practice this is not use
        self.circle_e = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_f = (self.pt_f[0] + self.lane_width, self.pt_f[1] - self.lane_width, self.lane_width/2.2)
        self.circle_g = (self.pt_d[0] - self.lane_width, self.pt_d[1] - self.lane_width, self.lane_width)
        self.circle_h = (self.pt_h[0] - self.lane_width, self.pt_h[1] - self.lane_width, self.lane_width/1.8)
        self.circle_i = (self.pt_i[0] + self.lane_width, self.pt_i[1] + self.lane_width, self.lane_width/1.2)
        self.circle_j = (self.pt_j[0] + self.lane_width, self.pt_j[1] + self.lane_width, self.lane_width/2)
        self.circle_j1 = (self.pt_j1[0] + self.lane_width, self.pt_j1[1] + self.lane_width, self.lane_width/2)
        self.circle_k = (self.pt_k[0] + self.lane_width*2.1, self.pt_k[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_l = (self.pt_l[0] + self.lane_width, self.pt_l[1] + self.lane_width, self.lane_width/2)
        self.circle_m = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_n = (self.pt_n[0] - self.lane_width*1.2, self.pt_n[1] + self.lane_width*2.1, self.lane_width/2)
        self.circle_o =  (self.pt_o[0] - self.lane_width, self.pt_o[1] - self.lane_width, self.lane_width/1.8)
        self.circle_p = (self.pt_p[0] - self.lane_width*2.8, self.pt_p[1] + self.lane_width*2.1, self.lane_width*1.1) #smaller multiplier to x increases x & decrease the multiplier to increase z
        self.circle_q = (self.pt_q[0] - self.lane_width, self.pt_q[1] - self.lane_width, self.lane_width)
        self.circle_r = (self.pt_r[0] + self.lane_width, self.pt_r[1] + self.lane_width, self.lane_width/2)
        self.circle_s = (self.pt_s[0] + self.lane_width*2.1, self.pt_s[1] - self.lane_width*1.2, self.lane_width*2)
        self.circle_t = (self.pt_t[0] + self.lane_width, self.pt_t[1] + self.lane_width, self.lane_width/2)
        self.circle_u = (self.pt_u[0] + self.lane_width*2.1, self.pt_u[1] - self.lane_width*1.2, self.lane_width*2)

        #the ranges near each corner that activates the circle path for the limo to follow
        self.act_range_a = (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_b = (self.lane_width /1.3, self.lane_width * 1.17)
        self.act_range_c = (self.lane_width / 1.5, self.lane_width * 1.5)
        self.act_range_d = (self.lane_width*1 , self.lane_width /2)
        self.act_range_e = (self.lane_width *1.1, self.lane_width/1.7 )
        self.act_range_f = (self.lane_width * 1.2, self.lane_width/1.4)
        self.act_range_g = (self.lane_width * 1, self.lane_width * 1)
        self.act_range_h = (self.lane_width /2, self.lane_width * 1.64)
        self.act_range_i = (self.lane_width /1.5, self.lane_width * 0.6)
        self.act_range_j = (self.lane_width /1.38, self.lane_width * 1.38)
        self.act_range_j1 = (self.lane_width /1.38, self.lane_width * 1.38)

        self.act_range_k = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_l = (self.lane_width /1.37, self.lane_width * 1.37)
        self.act_range_m = (self.lane_width * 1.25, self.lane_width/1.7 )
        self.act_range_n =  (self.lane_width * 1.3, self.lane_width /1.7)
        self.act_range_o =(self.lane_width /1.32, self.lane_width * 1.2)
        self.act_range_p = (self.lane_width * 0.85, self.lane_width * 0.85)
        self.act_range_q = (self.lane_width * 1.3, self.lane_width * 1.3)
        self.act_range_r = (self.lane_width /1.5, self.lane_width * 1.37)
        self.act_range_s = (self.lane_width *1.3, self.lane_width/1.7 )
        self.act_range_t = (self.lane_width /1.5, self.lane_width * 1.5)
        self.act_range_u =  (self.lane_width *1.3, self.lane_width/1.7 )


        #values of each line, each element is a tuple (kp, ki, kd)
        self.path_A_PID = (-0.00055, -0.000095, -0.001)
        self.path_B_PID = (0.00055, 0.00003, 0.0009)
        self.path_C_PID = (0.0008, 0.00008, 0.0012)
        self.path_D_PID = (-0.0008, -0.00007, -0.0008)
        self.path_D2_PID = (-0.0005, -0.00042, -0.001)
        self.path_E_PID =(-0.0004, -0.00053, -0.001)
        self.path_F_PID = (-0.0004, -0.00033, -0.0016)
        self.path_G_PID = (-0.0008, -0.00007, -0.0008)
        self.path_G1_PID = (-0.0008, -0.00007, -0.0008)
        self.path_H_PID = (0.00068, 0.00007, 0.0013)
        self.path_I_PID = (0.0008, 0.00008, 0.0008)
        self.path_J_PID = (-0.00035, -0.000075, -0.0012)
        self.path_K_PID = (-0.0008, -0.00004, -0.001)

        #PID values of each circle, each element is a tuple (kp, ki, kd)
        self.circle_a_PID = (-0.45, -0.00045, -0.037)
        self.circle_b_PID = (-0.45, -0.00045, -0.039)
        self.circle_c_PID = (-0.56, -0.00045, -0.037)
        self.circle_d_PID = (-0.0005, -0.00045, -0.03)
        self.circle_e_PID = (-0.003, -0.000045, -0.0017)
        self.circle_f_PID = (-0.50, -0.00045, -0.037)
        self.circle_g_PID = (-0.25, -0.000005, -0.07)
        self.circle_h_PID =(0.007, 0.0000012, 0.8)
        self.circle_i_PID = (-0.0026, -0.000045, -0.0037)
        self.circle_j_PID = (-0.6, -0.000005, -0.037)
        self.circle_j1_PID = (-0.6, -0.000005, -0.037)
        self.circle_k_PID = (-0.25, -0.000005, -0.07)
        self.circle_l_PID =(-0.6, -0.00045, -0.037)
        self.circle_m_PID = (-0.6, -0.00045, -0.037)
        self.circle_n_PID =(-0.45, -0.00045, -0.037)
        self.circle_o_PID = (-0.45, -0.00045, -0.67)
        self.circle_p_PID =  (-0.25, -0.000005, -0.7)
        self.circle_q_PID = (-0.25, -0.000005, -0.7)
        self.circle_r_PID = (-0.6, -0.00045, -0.037)
        self.circle_s_PID = (-0.6, -0.00045, -0.037)
        self.circle_t_PID = (-0.6, -0.00045, -0.037)
        self.circle_u_PID = (-0.6, -0.00045, -0.37)
